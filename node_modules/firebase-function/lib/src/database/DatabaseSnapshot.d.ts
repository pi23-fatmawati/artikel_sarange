import type * as admin from 'firebase-admin';
import { Crypter } from '../crypter';
import { type ObjectValue } from '../types/utils';
import { type IDatabaseScheme, type CryptedScheme } from './IDatabaseScheme';
import { type IDatabaseSnapshot } from './IDatabaseSnapshot';
export declare class DatabaseSnapshot<DatabaseScheme extends IDatabaseScheme> implements IDatabaseSnapshot<DatabaseScheme> {
    private readonly snapshot;
    private readonly cryptionKeys;
    constructor(snapshot: admin.database.DataSnapshot, cryptionKeys: Crypter.Keys);
    child<Key extends true extends CryptedScheme.IsCrypted<DatabaseScheme> ? never : (keyof DatabaseScheme & string)>(key: Key): DatabaseSnapshot<DatabaseScheme extends Record<string, IDatabaseScheme> ? DatabaseScheme[Key] : never>;
    value(crypted: 'decrypt'): true extends CryptedScheme.IsCrypted<DatabaseScheme> ? CryptedScheme.GetType<DatabaseScheme> : never;
    value(): true extends CryptedScheme.IsCrypted<DatabaseScheme> ? never : DatabaseScheme;
    hasChild(path: string): boolean;
    get hasChildren(): boolean;
    get numberChildren(): number;
    get key(): string | null;
    get exists(): boolean;
    forEach(action: (snapshot: IDatabaseSnapshot<ObjectValue<DatabaseScheme>>) => boolean | void): boolean;
    map<U>(transform: (snapshot: IDatabaseSnapshot<ObjectValue<DatabaseScheme>>) => U): U[];
    flatMap<U>(transform: (snapshot: IDatabaseSnapshot<ObjectValue<DatabaseScheme>>) => U[]): U[];
    compactMap<U>(transform: (snapshot: IDatabaseSnapshot<ObjectValue<DatabaseScheme>>) => U | undefined | null): U[];
    reduce<T>(initialValue: T, transform: (value: T, snapshot: IDatabaseSnapshot<ObjectValue<DatabaseScheme>>) => T): T;
    reduceInto<T>(initialValue: T, transform: (value: T, snapshot: IDatabaseSnapshot<ObjectValue<DatabaseScheme>>) => void): T;
}
