"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Crypter = void 0;
const RandomBitIterator_1 = require("./RandomBitIterator");
const BytesToBitIterator_1 = require("./BytesToBitIterator");
const CombineIterator_1 = require("./CombineIterator");
const utils_1 = require("./utils");
const aes_ts_1 = require("aes-ts");
const js_base64_1 = require("js-base64");
class Crypter {
    cryptionKeys;
    constructor(cryptionKeys) {
        this.cryptionKeys = cryptionKeys;
    }
    encryptAes(bytes) {
        const encrypter = new aes_ts_1.CBCEncryptor(this.cryptionKeys.encryptionKey.value, this.cryptionKeys.initialisationVector.value);
        return encrypter.encrypt((0, utils_1.addPadding)(bytes));
    }
    decryptAes(bytes) {
        const decrypter = new aes_ts_1.CBCDecryptor(this.cryptionKeys.encryptionKey.value, this.cryptionKeys.initialisationVector.value);
        return (0, utils_1.removePadding)(decrypter.decrypt(bytes));
    }
    encryptVernamCipher(bytes) {
        const key = (0, utils_1.randomBytes)(32);
        const randomBitIterator = new RandomBitIterator_1.RandomBitIterator(Uint8Array.from([...key, ...this.cryptionKeys.vernamKey.value]));
        const bytesToBitIterator = new BytesToBitIterator_1.BytesToBitIterator(bytes);
        const combineIterator = new CombineIterator_1.CombineIterator(randomBitIterator, bytesToBitIterator, utils_1.xor);
        return Uint8Array.from([...key, ...(0, utils_1.bitIteratorToBytes)(combineIterator)]);
    }
    decryptVernamCipher(bytes) {
        const randomBitIterator = new RandomBitIterator_1.RandomBitIterator(Uint8Array.from([...bytes.slice(0, 32), ...this.cryptionKeys.vernamKey.value]));
        const bytesToBitIterator = new BytesToBitIterator_1.BytesToBitIterator(bytes.slice(32));
        const combineIterator = new CombineIterator_1.CombineIterator(randomBitIterator, bytesToBitIterator, utils_1.xor);
        return (0, utils_1.bitIteratorToBytes)(combineIterator);
    }
    encryptVernamAndAes(bytes) {
        const vernamEncrypted = this.encryptVernamCipher(bytes);
        return this.encryptAes(vernamEncrypted);
    }
    decryptAesAndVernam(bytes) {
        const aesDecrypted = this.decryptAes(bytes);
        return this.decryptVernamCipher(aesDecrypted);
    }
    encodeEncrypt(data) {
        const decodedData = JSON.stringify(data);
        const dataBytes = (0, utils_1.unishortBytes)(decodedData ?? '');
        const encryptedData = this.encryptVernamAndAes(dataBytes);
        return js_base64_1.Base64.fromUint8Array(encryptedData, true);
    }
    decryptDecode(data) {
        if (data === '')
            return undefined;
        const dataBytes = js_base64_1.Base64.toUint8Array(data);
        const decryptedData = this.decryptAesAndVernam(dataBytes);
        const decodedData = (0, utils_1.unishortString)(decryptedData);
        return JSON.parse(decodedData);
    }
}
exports.Crypter = Crypter;
