"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FirebaseFunctions = void 0;
const functions_1 = require("firebase/functions");
const crypter_1 = require("../crypter");
const DatabaseType_1 = require("../types/DatabaseType");
const Expect_1 = require("./Expect");
const UtcDate_1 = require("../types/UtcDate");
const js_base64_1 = require("js-base64");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const Result_1 = require("../types/Result");
class FirebaseFunctions {
    functions;
    requestUrlComponent;
    cryptionKeys;
    callSecretKey;
    functionName;
    constructor(functions, requestUrlComponent, cryptionKeys, callSecretKey, functionName) {
        this.functions = functions;
        this.requestUrlComponent = requestUrlComponent;
        this.cryptionKeys = cryptionKeys;
        this.callSecretKey = callSecretKey;
        this.functionName = functionName;
    }
    function(key) {
        return new FirebaseFunctions(this.functions, this.requestUrlComponent, this.cryptionKeys, this.callSecretKey, this.functionName === undefined ? key : `${this.functionName}-${key}`);
    }
    async call(parameters) {
        const databaseType = new DatabaseType_1.DatabaseType('testing');
        const crypter = new crypter_1.Crypter(this.cryptionKeys);
        const expiresAtUtcDate = UtcDate_1.UtcDate.now.advanced({ minute: 1 });
        const functionName = this.functionName !== undefined ? `debug-${this.functionName}` : '';
        const callableFunction = (0, functions_1.httpsCallable)(this.functions, functionName);
        const httpsCallableResult = await callableFunction({
            verbose: 'coloredVerbose',
            databaseType: databaseType.value,
            callSecret: {
                expiresAt: expiresAtUtcDate.encoded,
                hashedData: (0, crypter_1.sha512)(expiresAtUtcDate.encoded, this.callSecretKey)
            },
            parameters: crypter.encodeEncrypt(parameters)
        });
        const result = await crypter.decryptDecode(httpsCallableResult.data.result);
        return (0, Expect_1.expectResult)(result);
    }
    async request(parameters) {
        const functionName = this.functionName !== undefined ? `debug-${this.functionName}` : '';
        const baseUrl = `https://${this.requestUrlComponent}.cloudfunctions.net/${functionName}`;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const joinedParameters = [...Object.entries(parameters), ['databaseType', 'testing']].map(parameter => `${parameter[0]}=${parameter[1]}`).join('&');
        const url = (0, js_base64_1.encodeURL)(`${baseUrl}?${joinedParameters}`);
        try {
            const response = JSON.parse(await (await (0, cross_fetch_1.default)(url)).json());
            return (0, Expect_1.expectResult)(Result_1.Result.success(response));
        }
        catch (error) {
            return (0, Expect_1.expectResult)(Result_1.Result.failure(error));
        }
    }
}
exports.FirebaseFunctions = FirebaseFunctions;
